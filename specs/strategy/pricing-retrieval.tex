下面我们将描述3种策略:每一种都比前一种更复杂。

被动:弱卡特尔-硬有线固定价格表
最小响应性:如果没有保证边界，则不对对等体进行转发。 

反应性-对下游价格上涨的反应，探索其他同行。如果没有其他选择，就会提高价格。如果下游的同行降低价格，它也会效仿。

积极主动:回复 


\subsection{被动策略\statusorange}\label{sec:pricing-retrieval}
下面的策略是节点如何使用上面描述的协议的基本方法。该策略的意图是尽可能容易地实施，而balbalbala

\subsubsection{保证金}
“ChunkDeliveryRequest”的节点价格总是至少是他想要的“保证金”+最便宜的上游peer的价格。 

\subsubsection{填充priceInformationRegistry}
最初，节点只知道从最接近的容器中提供内容的价格(price == ' margin ')。当这个节点收到他的第一个请求，提供的内容是距离他最接近的存储库边界一个接近订单的内容时，他首先会检查这个请求的价格是否超过他的边际。如果是这种情况，他将以0的价格转发' retriverequest '(因为状态还没有初始化)。如果在适当的仓中的上游对等体没有改变他的价格，这个对等体将返回一个' NewPrice '消息，其中价格等于下游对等体的' margin '。如果原始价格至少是“保证金”的2倍，节点可以以“保证金”的价格转发请求(并将另一个马林自己收进口袋)。从这一点开始，“状态”将为一个对等体和一个邻近体初始化。随后发送给这个peer的' retriverequests '将以' margin '的' price '发送。更远的区块价格更高。通过这个迭代过程，同伴将很快了解到这一点。如果所有对等点应用相同的' margin '， ' ChunkDelivery '的价格等于请求者和块之间的接近顺序乘以' margin '。如果对等的请求一块价格小于他的“保证金”+上游同行最便宜的价格,本,请求不转发,但立即回答“NewPrice”的信息与价格等于“保证金”+上游同行最便宜的价格,本。

\subsubsection{对价格差异的反应}
网络中没有对等收取“保证金”不同于默认的边缘,只“NewPrice”消息将发送到同龄人没有完全初始化他们的“状态”,同等的距离所请求的块和同行之间在一个特定的箱子,一个节点没有一块基于价格的首选供应商。但是，如果网络中的任何一个peer改变了他的价格，基于价格的偏好就会出现:

对于任何块请求:
—选择要转发请求的bin
—选择PO距离chunk最近的对等体
—选择价格最低的对等体
-如果有多个对等点具有相同的价格，则执行轮询负载均衡

由此，我们可以得出结论，如果对等体降低价格，他将收到更多的‘retriverequests’;如果对等体提高价格，他将收到更少的‘retriverequests’。与价格较低的上游peer连接的节点可能会决定在此距离上降低价格，以便接收更多请求。

\subsubsection{通知价格变动}
这是网络的利益，当有价格变化时，这将尽快传播到相关各方。价格变化可以由“保证金”的变化引起，或者由上游对等方的价格变化引起。在这两种情况下，对等体可能决定不通知其他对等体价格的下降——惟一的变化是它将以比以前更低的价格接受' retriverequests '。然而，如果不通知下游对等体，节点可能无法直接获得预期数量的额外客户端，因为下游对等体可能永远不会提出比以前更低的价格。出于这个原因，我们建议节点主动发送“NewPrice”消息给他的同伴，本质上是要求他们更新他们的“priceInformationRegistry”。在主动' NewPrice '消息的情况下，' chunkReference '可能是合成的，这意味着它不必响应一个实际的块;重要的是同行们更新他们的“价格信息注册表”。

\textbf{Overpriced bins}
自一个节点的价格取决于他的上游同行的价格,它会发生改变,他所有的上游同学之间的关系在某本是由昂贵的peers-effectively填充节点本身过于昂贵和下游的同行。为了解决这个问题，我们建议进行统计分析:如果一个节点在他的所有箱子上都有合理的价格，那么他将收到所有箱子相同数量的请求。如果一个节点接收到的对某个箱子的请求比其他箱子的请求少得多，他就会将那些被认为价格过高的对等体标记为无功能，蜂巢协议就会启动，建议新的对等体连接。 

\textbf{Reacting to demand increases/decreases}

如果一个节点的价格降低到最便宜，那么它将获得更多的流量。如果不能对流量的增加作出适当的响应，节点可能被迫在D时脱机

\subsubsection{配置选项}
将添加以下配置选项。 

\begin{verbatim}

|名称|单位|默认|
| -------- | -------- | -------- |
'保证金'支票簿的基础货币
| ' period ' | duration in seconds | 300 |
| ' maximum_upstream_bandwidth ' |带宽使用，以字节为单位每'周期' | TODO |
| ' high_water_mark ' | percentage:(upstream bandwidth used / ' period ') / (' maximum_upstream_bandwidth ') | 80%     |
| ' low_water_mark ' | percentage:(upstream bandwidth used / ' period ') / (' maximum_upstream_bandwidth ') | 20%     |
| ' margin_change ' | percentage | 1%     |

\end{verbatim}

下面是如何使用这些变量的。

\subsection{节点fabbd的行为}
1)给定一个特定的\lstinline{`chunkReference`}，节点选择将$`ChunkRequestMessage`$发送给该bin中所有节点中价格最低的节点。
2)如果从一个' chunkRequestMessage '返回一个' newPrice '消息，节点更新' priceInformationRegistry '并再次发送' chunkRequestMessage '，并根据更新的' priceInformationRegistry '选择对等体。 
4)当对等端请求一个特定的ChunkRequestMessage，并且在其本地存储中没有' chunkContent '，它转发' ChunkRequestMessage '(见1)，价格等于它收到的' ChunkRequestMessage '减去他的' margin '。
一个节点跟踪他的“带宽\_usage”(\lstinline{(upstream bandwidth used / `period`) / (`maximum\_upstream\_bandwidth`)})
6)当' bandWidth\_usage ' > ' high\_water\_mark '时，' margin '将为(1+ ' margin\_change ') * ' margin '
7)当' bandWidth\_usage ' < ' low\_water\_mark '时，' margin '将是(1- ' margin\_change ') * ' margin '。“保证金\_change”表示 
8)当一个节点可以得到更便宜的价格而不是“块”要求由“ChunkRequestMessage”(上游同行改变价格,数量的啤酒花小于平均请求相同的距离),他回答“ChunkDeliveryMessage”,将基于“ChunkRequestMessage”定价。 
9)当一个节点期望能够提供比他的同行目前知道的长期更低的价格时，他发送一个“NewPrice”消息给他的同行。 

\subsection{加密\statusgreen}\label{spec:format:crypto}

本节描述整个规范中使用的加密原语。它们暴露为buzz内置功能。
这些模块包括哈希、随机数生成、密钥派生、对称和非对称加密(ECIES)、挖掘(即寻找瞬时值)、椭圆曲线密钥生成、数字签名(ECDSA)、Diffie- Hellman共享秘密(ECDH)和柯西-里德-所罗门(CRS)擦除编码。

一些内置加密原语(尤其是sha3哈希和ECDSA ecrecover)复制了以太坊虚拟机的加密功能。这些是在以太坊api调用智能合约的帮助下定义的。这个智能合约只实现了“buzz”的原语，并且只有read方法。

\subsubsection{哈希}

基哈希函数实现了以太坊中使用的kecak256哈希。

\begin{definition}[Hashing]\label{def:hash}
\begin{lstlisting}[language=buzz1]
// /crypto

define function hash @input []byte
    ?and/with @suff
    return segment
as
    ethereum/call "sha3" with @input append= @suff
         on context contracts "buzz" 
\end{lstlisting}
\end{definition}  


\subsubsection{随机数生成}

\begin{definition}[Random number generation]\label{def:rng}
\begin{lstlisting}[language=buzz1]
// /crypto

define function random type 
    return [@type size]byte 

\end{lstlisting}
\end{definition}    


\subsubsection{Scrypt关键推导}

加密密钥派生函数实现了\lstinline{scrypt} \cite{percival2009stronger}。

\begin{definition}[Scrypt key derivation]\label{def:scrypt}
\begin{lstlisting}[language=buzz1]
// /crypto

define type salt as [segment size]byte

define type key as [segment size]byte

// params for scrypt key derivation function
// scrypt.key(password, salt, n, r, p, 32) to generate key

define type kdf
    n int // 262144
    r int // 8
    p int // 1

define function scrypt from @password
    with   salt 
    using  kdf
    return key

\end{lstlisting}
\end{definition}  

\subsubsection{矿业助手}

该模块提供了一个非常简单的helper函数，用于查找一个nonce，当该nonce作为挖掘函数的单个参数时返回true。

\begin{definition}[Mining a nonce]\label{def:mine}
\begin{lstlisting}[language=buzz1]
// /crypto

define type nonce as [segment size]byte

define function mine @f function of nonce return bool
as
    @nonce = random key
    return @nonce if call @f @nonce
    self @f
    
\end{lstlisting}
\end{definition}  

\subsubsection{对称加密}

对称加密在计数器模式下使用32字节块大小的修改块密码。
段密钥是通过将特定于块的加密密钥与计数器散列并再次散列生成的。这第二步是必需的，以便可以有选择地以第三方可证明的方式公开段，而不损害块的其余部分的安全性。

该模块提供保持输入长度的块密码加密。

\begin{definition}[Blockcipher]\label{def:crypt}
\begin{lstlisting}[language=buzz1]
// /crypto

// two-way (en/de)crypt function for segment
define function crypt.segment segment
    with key
    at @i uint8
as
    hash @key and @i        // counter mode 
        hash                // extra hashing
        to @segment length  // chop if needed
        xor @segment        // xor key with segment

// two-way (en/de)crypt function for arbitrary length 
define function crypt @input []byte
    with key
    return [@input length]byte
as
    @segments = @input each segment size    // iterate segments of input
        go crypt.segment at @i++ with @key  // concurrent crypt on segments
    return wait for @segments               // wait for results
        join                                // join (en/de)crypted segments
        
\end{lstlisting}
\end{definition}    

\subsubsection{椭圆曲线密钥}

公钥加密与以太坊相同，使用secp256k1椭圆曲线。  


\begin{definition}[Elliptic curve key generation]\label{def:ec-keys}
\begin{lstlisting}[language=buzz1]
// /crypto
define type pubkey  as [64]byte
define type keypair
    privkey [32]byte
    pubkey
    
define type address as [20]byte

define function address pubkey
    return address
as 
    hash pubkey 
        from 12

define function generate 
p    ?using entropy
as
    @entropy = random segment if no @entropy
    http/get "signer/generate?entropy=" append @entropy 
        as keypair

\end{lstlisting}
\end{definition}    

\subsubsection{非对称加密}

非对称加密实现基于secp256k1椭圆曲线的ECIES。 
%  TODO: this needs more detail

\begin{definition}[Asymmetric encryption]\label{def:asymmetric-encryption}
\begin{lstlisting}[language=buzz1]
// /crypto

define function encrypt @input []byte 
    for pubkey
    return [@input length]byte

define function decrypt @input []byte 
    with keypair
    return [@input length]byte

\end{lstlisting}
\end{definition}  


\subsubsection{签名}

Crypto的内置签名模块实现了基于secp2156k1椭圆曲线的ECDSA。实际的签名发生在作为独立进程运行的外部签名者中(可能在安全区域内)。按照以太坊的惯例，签名使用r/s/v格式表示和序列化，

\begin{definition}[Signature]\label{def:signature}
\begin{lstlisting}[language=buzz1]
// /crypto

define type signature
    r segment
    s segment
    v uint8
    signer private keypair
    

define type doc 
    preamble []byte
    context  []byte
    asset    segment
    
define function sign @input []byte 
    by keypair
    return signature
as
    @doc = doc{ "swarm signature", context caller, @input }
    @sig = http/get "signer/sign?text=" append @doc 
        append "&account=" append @keypair pubkey address
            as signature 
    @sig signer = @keypair
    @sig
    
define function recover signature
    with @input []byte
    from @caller []byte
    return pubkey
as
    @doc =  doc{ "swarm signature", @caller, @input } as bytes
    ethereum/call "ecrecover" with 
        on context contracts "buzz" 
            as pubkey

\end{lstlisting}
\end{definition}  


\subsubsection{Diffie-Hellmann共享密钥}

共享秘密模块使用常见的secp256k1椭圆曲线实现基于椭圆曲线的Diffie—Helmann共享秘密(ECDH)。
实际的DH来自外部签名者，然后用盐散列在一起。

\begin{definition}[Shared secret]\label{def:dh}
\begin{lstlisting}[language=buzz1]
// /crypto

define function shared.secret between keypair
    and pubkey
    using salt
    return [segment size]byte
as
    http/get "signer/dh?pubkey=" append @pubkey append "&account=" @keypair address
        hash with @salt

\end{lstlisting}
\end{definition}  

\subsubsection{擦除编码}\label{spec:format:erasure}

Erasure编码接口为直接工作在块列表上的编码器/解码器提供了包装\lstinline{extend/repair}。%
%
\footnote{柯西-里德-所罗门擦除码基于\url{https://github.com/klauspost/reedsolomon}。
}

假设$n$退出$m$编码。
\lstinline{extend}接受$n$数据块的列表和一个表示所需对等数的参数。它只返回奇偶校验块。
\lstinline{repair}接受一个$m$块列表(使用\emph{所有}奇偶扩展)和一个$p=m-n$奇偶数的参数，该参数将最后一个$p$块指定为奇偶块。它只返回$n$修复的数据块列表。
编码器不知道哪些部分是无效的，因此应该在参数中将缺失或无效的块设置为\lstinline{nil}进行修复。
如果需要修复奇偶校验块，可以调用\lstinline{repair @chunks with @parities; extend with @parities}

\begin{definition}[CRS erasure code interface definition]\label{def:crs}
\begin{lstlisting}[language=buzz1]
// /crypto/crs

define function extend @chunks []chunk 
    with @parities uint
    return [@parities]chunk

define function repair @chunks []chunk   
    with @parities uint
   return [@chunks length - @parities]chunk

\end{lstlisting}
\end{definition}

\begin{definition}[CRS erasure coding parameters]\label{def:crs-params}
\begin{lstlisting}[language=buzz1]
// /crypto/crs
define strategy as "race"|"fallback"|"disabled"

define type params 
    parities uint
    strategy 
     
\end{lstlisting}
\end{definition}


\subsection{状态存储\statusgreen}\label{spec:format:statestore}
% \input{specs/api/statestore.tex}

\begin{definition}[State store]\label{def:state-store}
\begin{lstlisting}[language=buzz1]
// /statestore

define type key []byte
define type db  []byte
define type value []byte

define function create db

define function destroy db

define function put value
    to db
    on key
    
define function get key 
    from db
    return value
\end{lstlisting}
\end{definition}


\subsection{本地上下文和配置\statusgreen}\label{spec:format:local}
% \input{specs/api/local.tex}


\begin{definition}[Context]\label{def:scontext}
\begin{lstlisting}[language=buzz1]
// /context

define type contract as "buzz"|"chequebook"|"postage"|""

define type context
    contracts [contract]ethereum/address 
\end{lstlisting}
\end{definition}
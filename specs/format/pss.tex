\subsection{直接pss消息与木马块}

Pss有两种基本类型，一个消息和一个木马块结构，它封装加密的序列化消息，并包含一个nonce，该nonce被挖掘来使结果块的内容地址(BMT哈希)匹配目标。


\begin{definition}[Basic types: topic, targets, recipient, message and trojan]\label{def:pss-message}
\begin{lstlisting}[language=buzz1]
// /pss


define type topic        as [segment size]byte       // obfuscated topic matcher
define type targets      as [][]byte       // overlay prefixes 
define type recipient    as crypto/pubkey

// pss message
define type message 
    seal    segment            
    payload [!:4030]byte    // varlength padded to 4030B
    
// trojan chunk
define type trojan 
    nonce   segment           // the nonce to mine 
    message [4064]byte        // encrypted msg 
\end{lstlisting}
\end{definition}


消息的编码方式允许完整性检查，同时模糊了主题。将有效负载与主题打包的操作称为\emph{密封}


\begin{definition}[Sealing/unsealing the message]\label{def:pss-sealing}
\begin{lstlisting}[language=buzz1]
// /pss

define function seal @payload []byte
    with topic
as
    @seal = hash @payload and @topic // obfuscate topic
        xor @topic          
    return message{ @seal, @payload }

define function unseal message
    with topic 
as
    @seal = hash @message payload and @topic 
    if @topic == @seal xor @message seal then // check 
        return @payload 
    return nil
    
\end{lstlisting}
\end{definition}

函数在消息和木马块之间进行\lstinline{wrap/unwrap}转换。\lstinline{wrap}接受一个可选的接收方公钥来对消息进行非对称加密。
目标是一个覆盖地址前缀列表，它是从接收者的覆盖地址派生出来的，指定长度以保证匹配它的块在推送同步时只会以接收者作为结果。   

\begin{definition}[Wrapping/unwrapping]\label{def:wrap}
\begin{lstlisting}[language=buzz1]
// /pss

define function wrap message 
    for recipient
    to  targets
as 
    @msg = @message 
        (crypto/encrypt for @recipient if @recipient) 

    @nonce = crypto/mine @n such that
        @targets any is prefix of
            trojan{@n, @msg} as chunk address 
    trojan{@nonce, @msg} as chunk 

define function unwrap chunk
    for recipient
as
    @chunk bytes 
        (crypto/decrypt  for @recipient if @recipient)
            as message

\end{lstlisting}
\end{definition}

当数据块到达节点时，存储组件将\lstinline{pss/deliver}作为钩子调用。
首先，使用接收方私钥对消息进行拆封，并使用所有订阅的主题API客户端对消息进行拆封。如果解封成功，则验证消息完整性和主题匹配，因此将有效负载写入为相关主题注册的流中。

\begin{definition}[Incoming message handling]\label{def:delivery}
\begin{lstlisting}[language=buzz1]
// /pss

// mailbox is a handler type, expects payload
// sent sealed with the topic to be delivered via the stream 
define type mailbox
    topic
    deliveries stream of []byte 
    
define context mailboxes as []mailbox

define function deliver chunk
    @msg = @chunk unwrap for context recipient
    mailboxes each @mailbox 
        @payload = unseal @msg  with @mailbox topic
        if @payload then 
            write @msg payload 
                to @mailbox deliveries 
    

\end{lstlisting}
\end{definition}


\begin{definition}[pss API: send]\label{def:send}
\begin{lstlisting}[language=buzz1]
// /pss

define function send @payload []byte
    about topic
    for recipient
    ?to    targets
has api POST on "/pss/<recipient>/<topic>(?targets=<targets>)"
    with @payload as body
as 
    targets = lookup.targets for @recipient if no @targets
    context tag = tag/tag{}
    seal @payload with @topic        // seal with topic
        wrap for @recipient          // encrypt if given recipient
            to @targets              // mine nonce and returns trojan chunk
                store                // to be sent by push-sync
    return tag                       // tag to monitor status 
    
\end{lstlisting}
\end{definition}

\begin{definition}[pss API: receive]\label{def:receive}
\begin{lstlisting}[language=buzz1]
// /pss

define function receive about topic 
    on uint64 @channel
has api POST on "/pss/subscribe/<topic>(?on=<channel>)"
as 
    @stream = open @channel
    context mailboxes append= mailbox{ @topic, @stream }
    
define function cancel topic
    on @channel uint64
has api DELETE on "/pss/subscribe/<topic>(?on=<channel>)"
as
    context mailboxes any ch
\end{lstlisting}
\end{definition}

\subsection{信封}

\begin{definition}[Envelope]\label{def:pss-envelope}
\begin{lstlisting}[language=buzz1]
// /pss

define type envelope
    id  [segment size]byte
    sig crypto/signature
    ps  postage/stamp   
    
\end{lstlisting}
\end{definition}

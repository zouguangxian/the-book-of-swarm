
Swarm中的对称加密在counter模式中使用了一个稍微修改过的块密码版本。

如果给定了块的加密种子，则该加密种子来自主种子，否则只是随机生成的。 

对单个块(和整个内容)的引用是加密数据的散列和解密密钥的连接(请参阅\ref{def:chunk-reference})。这意味着加密的Swarm引用(64字节)将比未加密的Swarm引用(32字节)长。当一个节点同步加密块时，它不会以任何方式与其他节点共享完整的引用(或解密密钥)。因此，其他节点将无法访问原始数据，甚至无法检测一个chunk是否被加密。

\begin{definition}[Chunk encryption/decryption API]\label{def:encrypt}
\begin{lstlisting}[language=buzz1]

// generate key for a chunk
define encryption.key for chunk
    ?with @seed [segment.size]byte
as
    return crypto/random key if no @seed // generate new 
    hash @seed and @chunk address

define function encrypt chunk
    with key 
as   
    @segments = @chunk data pad to chunk size
        each segment size 
            go crypt at @i++ with @key 
    @span = chunk span crypt at branches with @seed 
    @payload = wait for @segments 
        join
    chunk{ @span, @payload } 


define function decrypt chunk
    with key 
as       
    @span  = @chunk span 
        crypt at branches with @key 
    @segments = chunk data to @span payload.length
        each segment size 
            go crypt at @i++ with @key
    @payload = wait for @segments 
        join
    chunk{ @span, @payload } 

\end{lstlisting}
\end{definition} 
       
        
加密的Swarm块与明文块没有区别，因此不需要在P2P协议级别上更改以适应它们。提议的加密方案是端到端，这意味着加密和解密是在端点上完成的，即http代理层运行的地方。这有一个重要的后果，即公共网关不能用于加密内容。另一方面，蜂房模块化设计允许客户端在外部api上加密，同时通过网关代理所有其他调用。


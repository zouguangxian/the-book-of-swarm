\subsection{包裹地址\statusyellow}

Swarm的Overlay网络使用32字节的地址。为了帮助地址空间的统一利用，这些地址必须使用哈希函数派生。Swarm节点必须关联\gloss{Swarm base account}或\gloss{bzz account}, \gloss{Swarm base account}或\gloss{bzz account}是一个节点(操作符)必须拥有其私钥的以太坊帐户。节点的Overlay地址由该帐户的公钥派生。 

\begin{definition}[Swarm overlay address of node A]\label{def:overlay}
\begin{equation}
\mathit{overlayAddress}(A) \defeq \mathit{Hash}(\mathit{ethAddress}|\mathit{bzzNetworkID})         
\end{equation}
where
\begin{itemize}
\item $\mathit{Hash}$ is the 256-bit Keccak SHA3 hash function
\item \emph{ethAddress} - the ethereum address  (bytes,  not hex) derived from the node's base account public key: $\mathit{account}\defeq\mathit{PubKey}(K_A^\mathit{bzz})[12:32]$), where
    \begin{itemize}
    \item \emph{PubKey} is the \emph{uncompressed} form of the public key of a keypair \emph{including} its $04$ (uncompressed) prefix.
    \item $K_A^\mathit{bzz}$ refers to the node's bzz account key pair
    \end{itemize}
\item \emph{bzzNetworkID} is the bzz network id of the swarm network serialised as a little-endian binary \emph{uint64}.
\end{itemize}
\end{definition}

从某种程度上说，从公钥获得节点地址意味着Overlay地址空间不是免费可用的:要占用一个地址，必须拥有其他节点需要验证的地址的私钥。使用共享的共识文本块的数字签名，这样的身份验证很容易，参见\ref{spec:format:bzzaddress}。

\subsection{衬底地址\statusyellow}

为了使对等点定位网络上的一个节点，Overlay地址与一个底层地址配对。底层地址是节点在底层传输层上的网络位置的字符串表示形式。节点使用它来拨号其他节点来建立peer - to - peer连接。 

\begin{definition}[Swarm underlay multiaddress]\label{def:underlay}
\begin{lstlisting}[]

\end{lstlisting}
\end{definition}


\subsection{BZZ地址\statusyellow}

Bzz地址在功能上是Overlay地址和底层地址的配对。为了确保Overlay地址来自于节点拥有的帐户，以及可验证地证明一个节点可以被调用的底层地址，bzz地址以以下传输格式通信:

\begin{definition}[Swarm bzz address transfer format]\label{def:bzz-address}
\begin{lstlisting}[]
// ID: /swarm/handshake/1.0.0/bzzaddress

syntax = "proto3";

message BzzAddress {
    bytes Underlay = 1;
    Signature Sig  = 2;
    bytes Overlay  = 3; 
}
\end{lstlisting}
\end{definition}

在这里，签名是为了证明一个网络的Overlay层和一个底层地址的关联。 

\begin{definition}[Signed underlay address of node A]\label{def:signed-underlay}
\begin{equation}
\mathit{signedUnderlay}(A) \defeq \mathit{Sign}(\mathit{underlay}|
\mathit{overlay}|\mathit{bzzNetworkID})         
\end{equation}
\end{definition}

使用明文附加的Overlay层和bzz网络ID，并将生成的公钥与bzz网络ID散列。 

\begin{definition}[Node addresses: overlay, underlay,  bzz address]\label{def:bzz-types}
\begin{lstlisting}[language=buzz1]
// /bzz

define type overlay as [segment size]byte
define type underlay []byte

define function overlay.address of pubkey 
    within @network uint64 
as
    hash @pubkey address and @network 
        as overlay

define function valid bzz.address 
    within @network uint64
as
    assert @bzz.address overlay == overlay.address of crypto/recover from @bzz.address signature with @bzz.address @underlay
        within @network
        
define function bzz.address of overlay
    from underlay 
    by @account ethereum/address
as
    @sig = crypto/sign @underlay by @account
    bzz.address{ @overlay, @underlay, @sig }

\end{lstlisting}
\end{definition}




In order to get the overlay address from the transfer format peer info, one recovers from signature the peer's base account public key using the plaintext that is constructed as per \ref{def:signed-underlay}. From the public key, the overlay can be calculated as in \ref{def:overlay}. The overlay address thus obtained needs to be checked against the one provided in the handshake.

Signing of the underlay enables preflight authentication of the underlay of a trusted but not connected node. 

Since underlays are meant to be volatile, we can assume and in fact expect multiple underlays signed by the same node. However, these are meant to be temporally ordered. So one with a newer timestamp invalidates the older one. 

In order to make sure that the node connected through that underlay does indeed operate the overlay address, its authentication must be obtained through the peer connection that was initiated by dialing the underlay. The This protects against malicious impersonation of a trusted overlay potentially. 
首先，让我们定义一些基本类型，如\emph{载荷、跨段}。这些固定长度的字节片支持基本单元(如\lstinline{segment size}或\lstinline{payload size})的详细表达式。

\begin{definition}[segment, payload, span, branches]\label{def:chunk-constants}
\begin{lstlisting}[language=buzz1]
// /chunk

define type segment as [32]byte    // unit for type definitions
define type payload as [:4096]byte // variable length max 4Kilobyte
define type span as uint64         // little endian binary marshalled

define function branches 
    as payload size / segment size

\end{lstlisting}
\end{definition}

现在我们来看看\emph{地址,关键}和\emph{参考}的定义:                                             

\begin{definition}[Chunk reference]\label{def:chunk-reference}
\begin{lstlisting}[language=buzz1]
// /chunk

define type address as [segment size]byte

define type reference 
    address                   // result of bmt hash
    key if context.encryption // decryption key optional (context dependent)

\end{lstlisting}
\end{definition}

现在，将chunk定义为具有跨度和有效载荷的对象。

\begin{definition}[Content addressed chunk]\label{def:chunks}
\begin{lstlisting}[language=buzz1]
// /chunk

define type chunk
    span      // length of data span subsumed under node
    payload   // max 4096 bytes 

define function address of chunk
as
    @chunk payload bmt/hash with @chunk span 

define function create from payload
    ?over span
as
    @span = @payload length if no @span
    @chunk = chunk{ @span, @payload }
    return @chunk if no context encryption
    @key = encryption.key for @chunk 
    @chunk encrypt with @key
\end{lstlisting}
\end{definition}

其中length是length字段的内容，reference size是引用哈希值和解密密钥的大小之和，解密密钥目前是64，因为我们使用的是256位哈希值和256位密钥。

以便在返回明文块之前删除解密后的填充。 

\begin{definition}[Span to payload length]\label{def:span}
\begin{lstlisting}[language=buzz1]
// /chunk

define function payload.length of span
as
    while @span >= 4096 
        @span = @span + 4095
           / 4096
           * reference size
    return @span
\end{lstlisting}
\end{definition}

最后，我们可以定义用于检索和存储的块的公共API。

\begin{definition}[Chunk API retrieval]\label{def:retrieve}
\begin{lstlisting}[language=buzz1]
// /chunk

define function retrieve reference
has api GET on "chunk/<reference>"
as 
    retrieve @reference address as chunk
        (decrypt with @reference key if @reference key)
\end{lstlisting}
\end{definition}


\begin{definition}[Chunk API: storage] \label{def:store}
\begin{lstlisting}[language=buzz1]
// /chunk


define function store payload
    ?over span 
has api POST on "chunk/(?span=<span>)"
    from payload as body
as 
    @chunk = create from @payload over @span
    reference{ @chunk address, @chunk key }
\end{lstlisting}
\end{definition}



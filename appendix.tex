
\chapter{正规化和证明}\label{sec:formalisation}

\section{对数距离和接近顺序\statusgreen}\label{sec:proximity}
将具有固定长度$d$的位序列集合看作空间中的点。我们可以定义一个距离度量$\chi$
两个这样的序列之间的距离定义为它们的按位异或($\xor$)的双端数值。

\begin{definition}[XOR distance ($\chi$)]\label{def:xor}
\begin{equation}
\chi(x, y) \defeq \mathit{Uint}(x  \xor y)
\end{equation}
\end{definition}

给定固定长度$d>0$，在这个空间中存在一个最大距离，因此我们可以定义\emph{正常的距离}及其倒数\emph{接近}的概念:

\begin{definition}[normalised XOR distance ($\overline{\chi}$)]\label{def:normalisedxor}
\begin{equation}
\overline{\chi}(x, y) \defeq \frac{\chi(x,y)}{2^d-1}
\end{equation}
\end{definition}

\begin{definition}[proximity]\label{def:proximity}
\begin{equation}
\mathit{Proximity}(x, y) \defeq \frac{1}{\overline{\chi}(x,y)}
\end{equation}{}
\end{definition}


\emph{接近顺序(PO)}是距离的离散对数缩放。


\begin{definition}[Proximity order ($\PO$)]\label{def:xorPO}
\begin{equation}
\begin{split}
\PO&: \Keys \times\Keys\mapsto \overline{0,d}\\
\PO(x,y) &\defeq 
\begin{cases}
d & \text{ if } x=y\\
\mathit{int}(\log_2(\mathit{Proximity}(x, y)))&\text{otherwise}\\
\end{cases}
\end{split}
\end{equation}
\end{definition}


实际上，$\PO(x,y)$是$x$和$y$大端二进制表示中最长的公共前缀的长度。因此，最实用的方法是从左边开始计算二进制地址的匹配位。因此，Kademlia属于DHT-s \cite{rowstron2001pastry,zhao2004tapestry}的前缀匹配类。接近度的最大可能值是$d$的总比特数。 

取相对于不动点的接近顺序，$x_0$将所有点划分为
空间，由长度为$d$的所有可能的位序列组成等价类。每节课的分数都在
与$x_0$的距离是上一节课的一半。此外，任何属于同一类的两点之间的距离最多是它们到$x_0$的距离的一半。 
我们可以将接近阶函数的重要性质推广如下:

\begin{definition}[Proximity order definitional properties]\label{def:PO}
\begin{equation}
\PO: \Keys\times \Keys\mapsto \overline{0,d}
\end{equation}

% \begin{equation}
\begin{subequations}
  \begin{align}
    \label{eq:PO-constraint-symmetry} \text{reflexivity:  }&\forall x,y\in \mathcal{K}, \PO(x,y)=\PO(y,x)\\
    \label{eq:PO-constraint-monotonicity}\text{monotonicity:   }&\forall x,y,z\in \mathcal{K}, \PO(x,y)=k \land  \PO(x,z)=k \Rightarrow  \PO(y,z)>k\\
\label{eq:PO-constraint-transitivity}\text{transitivity:   }&\forall x,y,z\in \mathcal{K}, \PO(x,y)<\PO(y,z) \Rightarrow \PO(x,z)=\PO(x,y)
   \end{align}
\end{subequations}
% \end{equation}
\end{definition}

给定一组点均匀分布在空间(如一个哈希函数的结果),接近命令映射到一系列的子集与负指数规模基数,即阿宝本$0$一半的任何随机样本点,阿宝本1有一个第四,阿宝本2八分之一等。

\section{图拓扑\statusgreen中的接近顺序}

本节概述了一个图形理论方法的Kademlia拓扑\cite{aspnes2007skip}。
考虑空间中距离为和的点的集合$V$ 
二元关系$R$。定义一个有向图，其中集合中的每个点都是一个顶点，任何两个顶点$x$和$y$如果与$R$相关，则它们与一条边相连。 


$R$与特定点$x_0$的关系点可以通过它们相对于$x_0$的接近顺序来索引。这个索引称为\gloss{Kademlia table}。
然后，Kademlia表可以作为图遍历中查找两点之间路径的局部决策的基础。 


\begin{definition}[Kademlia table]\label{def:kademlia-table}
\begin{equation}
\begin{split}
&\mathit{Kad}_x: \overline{0,d} \mapsto \mathcal{P}(\mathit{V})\\
&\forall y, \langle x, y \rangle \in \mathit{Edges}(G) \rightarrow y \in \mathit{Kad}_x(p) \Longleftrightarrow \PO(x,y)=p 
\end{split}
\end{equation}
\end{definition}

我们说点\emph{Kademlia连接}(或点的连通性Kademlia属性)如果(1)连接到至少一个节点为每个接近订单(但不包括)一些最大值$d$(称为\gloss{saturation depth})和(2)连接到所有节点的邻近秩序相对于节点大于或等于$d$。

\begin{definition}[Kademlia connectivity]\label{sec:kademlia-connectivity}
\begin{equation}
\exists d, 0\leq d \leq l, \text{such that}
\begin{subequations}
(1)\forall p<d, |\mathit{Kad}_x(p)|>0 \\
(2)\forall y\in V, PO(x,y)=p\geq d \longrightarrow y\in\mathit{Kad}_x(p) 
\end{subequations}
\end{equation}
\end{definition}


如果一个连通子图的每个点都有Kademlia连通性，那么我们说这个子图有一个\gloss{Kademlia topology}。与Kademlia拓扑图形,(1)任意两点之间的路径必须存在,(2)这条路只能被发现使用决策基于本地信息每一跳,(3)保证终止在任何步骤比目的地从一开始的深度点+ 1。 

操作步骤如下。给定点$x$和$y$，构造路径$x_0=x , x_1, ..., x_k=y$，使$x_{i+1}\in \mathit{PO}(x_i, x_{i+1})=\mathit{PO}(x_i, y)$，即从源点开始，从目标地址所在的PO bin中的可用选项中选择下一个点。由于上面定义的Kademlia连通性的第一个假设，这样一个点必须存在。由于前面的另一个猜想，实际的容器在每一步都必须是单调递增的，并且可以从零开始。因此，对于每一个$0<i\leq l$, $\mathit{PO}(x_{i}, y)\geq i$。因此，由于存在$d\leq d_y$，因此 
$\mathit{PO}(x_{d}, y)\geq d_y$。这一点，加上上面的第二个Kademlia连接标准，意味着$x_d=y$和$k=d$或$y$连接到$x_d$，因此我们可以选择$x_{d+1}=y$和$k=d+1\leq d_y+1$。

\begin{theorem}{在具有Kademlia拓扑的图中，任意两点都可以连通，并且可以根据路径长度上界为节点数对数的局部Kademlia表来构造遍历路径。}

\begin{proof}



\qed
\end{proof}
\end{theorem}

\section{构建kademlia拓扑}

\section{填写邮票批次\statusgreen的复杂性}\label{sec:complexity-filling}

当每个碰撞槽都被填满时，邮资批会被最优地利用。虽然哈希是均匀的，但由于方差，我们不能保证$2^d$独立的哈希总是映射到一批深度$d$的碰撞槽。
我们提出了各种挖掘块的方法:通过(1)选择木马块的nonce(见\ref{sec:trojan})，(2)选择加密密钥(见\ref{sec:postage-stamps})，或(3)选择单个所有者块的索引(见\ref{sec:addressed-envelopes})。无论我们以何种方式挖掘数据块，我们都可以用相同的方式计算找到接受印章的$i$-th冲突槽的地址的几率，即。


\begin{equation}
\mathit{PO}(\mathit{H}(\mathit{Enc}(k, c)), \mathit{CS}(i))\geq\mathit{D},
\text{ where }\mathit{CS}(i)\defeq i*2^{256-D}
\text{ for }0\leq i\leq  2^D.
\end{equation}

如果用户希望在使用另一个邮票之前总是填满他们的邮票批次，对于每一个新块，就少一个选择来选择一个自由碰撞槽。让概率变量$X^n_i$表示当$n$插槽中的$i$空闲时，寻找插槽所需的试验次数。我们需要至少一次试验的概率为$\frac{n-i}{n}$，一般情况下:


\begin{equation}\label{eq:conditional}
\mathit{P}(X^n_i\geq j+1|X^n_i\geq j)=\frac{n-i}{n}\\
\end{equation}

因此，$i$-th块的预期试验次数为: 

 \begin{subequations}   \begin{align}
\mathit{E}(X^n_i)&=\sum^\infty_{j=1}j\mathit{P}(X^n_i=j)\\
&=\mathit{P}(X^n_i\geq 1)-\mathit{P}(X^n_i\geq 2)+2(\mathit{P}(X^n_i\geq 2)-P(X^n_i\geq 3))+\ldots\\
&= \mathit{P}(X^n_i\geq 1)+\mathit{P}(X^n_i\geq 2)+\ldots
\end{align} \end{subequations}

两边乘以$\frac{n-i}{n}$，然后使用\ref{eq:conditional}中定义的等价性，得到:

 \begin{subequations}   \begin{align}
\mathit{E}(X^n_i)\frac{n-i}{n}&=\mathit{P}(X^n_i\geq 1)\mathit{P}(X^n_i\geq 2|X^n_i\geq 1)+\mathit{P}(X^n_i\geq 2)\mathit{P}(X^n_i\geq 3|X^n_i\geq 2)+\ldots\\
&=\mathit{P}(X^n_i\geq 2)+\mathit{P}(X^n_i\geq 3)+\ldots\\
&=\mathit{E}(X^n_i)-\mathit{P}(X^n_i\geq 1)\\
&=\mathit{E}(X^n_i)-\frac{n-i}{n}
\end{align} \end{subequations}

由此，我们解决到ededd:

 \begin{subequations}   \begin{align}
\mathit{E}(X^n_i)(1-\frac{n-i}{n})&=1\\
\mathit{E}(X^n_i)&=\frac{n}{i}
\end{align} \end{subequations}

整个批次的平均值($n=2^D$)给出%
%
\footnote{看到调和级数 
\url{https://en.wikipedia.org/wiki/Harmonic\_series\_(mathematics)\#Rate\_of\_divergence}。}

 \begin{subequations}   \begin{align}
\sum_{i=1}^{2^D}\frac{2^D}{i}\frac{1}{2^D}
&=\sum_{i=1}^{2^D}\frac{1}{i}\\
&=\mathit{ln}(2^D)+1\\
&=\frac{\mathit{log}_2(2^D)}{\mathit{log}_2(e)}+1\\
&=D*0.6931+1
\end{align} \end{subequations}

\section{块检索的平均跳数}

本节给出了随机非缓存块的预期跳数的正式估计。  
\cite{roos2013comprehending, roos2015determining}已经分析了传统卡德米亚的跳数。

\section{分发请求}

在本节中，我们推导出一个平均节点所经历的每个PO bin请求的分布。

\section{Epoch-based提要\statusgreen}\label{sec:epoch-based-feeds-appendix}
\subsection*{更新示例\statusgreen}
 
假设我们想在5分钟后更新资源。Unix Time现在是$1534093015$。
我们计算$\mathit{epochBaseTime}(1534093015, 25) = 1509949440$。
这与$\langle  1534093015, 25\rangle$之前的时代相同。因此，我们降低水平，再次计算:
$\mathit{epochBaseTime}(1534093015, 24) = 1526726656$。因此，下一次更新将位于$\langle  1526726656, 24\rangle$

如果发行商每5分钟更新一次资源，epoch网格将呈现如下:

{\small
\begin{tabular}{c|c}
\begin{tabular}{r|l|l}
update & timestamp & epoch representation\\
1 & 1534092715 & $\langle  1509949440, 25\rangle$\\
2 & 1534093015 & $\langle  1526726656, 24\rangle$\\
3 & 1534093315 & $\langle  1526726656, 23\rangle$\\
4 & 1534093615 & $\langle  1530920960, 22\rangle$\\
5 & 1534093915 & $\langle  1533018112, 21\rangle$\\
6 & 1534094215 & $\langle  1534066688, 20\rangle$\\
7 & 1534094515 & $\langle  1534066688, 19\rangle$\\
8 & 1534094815 & $\langle  1534066688, 18\rangle$\\
9 & 1534095115 & $\langle  1534066688, 17\rangle$\\
10 & 1534095415 & $\langle 1534066688, 16\rangle$\\
11 & 1534095715 & $\langle 1534066688, 15\rangle$\\
12 & 1534096015 & $\langle 1534083072, 14\rangle$\\
13 & 1534096315 & $\langle 1534091264, 13\rangle$\\
14 & 1534096615 & $\langle 1534095360, 12\rangle$\\
15 & 1534096915 & $\langle 1534095360, 11\rangle$
\end{tabular}
&
\begin{tabular}{r|l|l}
update & timestamp & epoch representation\\
16 & 1534097215 & $\langle 1534096384, 10\rangle$\\
17 & 1534097515 & $\langle 1534096896, 9\rangle$\\
18 & 1534097815 & $\langle 1534097408, 11\rangle$\\
19 & 1534098115 & $\langle 1534097408, 10\rangle$\\
20 & 1534098415 & $\langle 1534097920, 9\rangle$\\
21 & 1534098715 & $\langle 1534098176, 8\rangle$\\
22 & 1534099015 & $\langle 1534098432, 10\rangle$\\
23 & 1534099315 & $\langle 1534098944, 9\rangle$\\
24 & 1534099615 & $\langle 1534099200, 8\rangle$\\
25 & 1534099915 & $\langle 1534099456, 15\rangle$\\
26 & 1534100215 & $\langle 1534099456, 14\rangle$\\
27 & 1534100515 & $\langle 1534099456, 13\rangle$\\
28 & 1534100815 & $\langle 1534099456, 12\rangle$\\
29 & 1534101115 & $\langle 1534099456, 11\rangle$\\
30 & 1534101415 & $\langle 1534100480, 10\rangle$
\end{tabular}
\end{tabular}
}


\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{fig/feeds/00.png}\\
\includegraphics[width=\textwidth]{fig/feeds/01.png}\\
\includegraphics[width=\textwidth]{fig/feeds/02.png}\\
\includegraphics[width=\textwidth]{fig/feeds/03.png}
\caption[Updates of epoch-based feed in the epoch grid]{Updates of epoch-based feed in the epoch grid. Epochs occupied are marked in yellow. }
\label{fig:feeds-update}
\end{figure}

如果发行商每5分钟更新一次内容($300s$)，我们就可以期待更新内容停留在第8-9个关卡($2^8 = 256s$, $2^9 = 512s$)。然而，发行商可以随时改变更新频率，或者只是随机更新。这并不影响算法。

\subsection*{并行算法查找最新更新的\statusorange}\label{sec:feeds-lookup-algo}

本节介绍了查找基于纪元的提要的最新更新的算法步骤(请参阅\ref{sec:epoch-based-feeds})。

\begin{figure}[htbp]
\centering
\begin{tabular}{c|c}
\includegraphics[width=.5\textwidth]{fig/feeds/0.png}&\includegraphics[width=.5\textwidth]{fig/feeds/1.png}\\
\includegraphics[width=.5\textwidth]{fig/feeds/2.png}&\includegraphics[width=.5\textwidth]{fig/feeds/3.png}\\
\includegraphics[width=.5\textwidth]{fig/feeds/4.png}&\includegraphics[width=.5\textwidth]{fig/feeds/5.png}\\
\includegraphics[width=.5\textwidth]{fig/feeds/6.png}&\includegraphics[width=.5\textwidth]{fig/feeds/7.png}
\end{tabular}
\caption[Latest update lookup algorithm for time based feeds]{Latest update lookup algorithm for time based feeds: steps. Known updates (U1) are marked in yellow. The hint is light orange (U2). Updates marked in grey (U3-U9) are unknown. $t=14$ indicates the current time, Step 1: lookahead (LA1) area (blue) and lookback (LB1) area (pink); }
\label{fig:feeds-lookup-1}
\end{figure}

\gloss{lookahead area}表示如果R1成功，将继续探索的区域，而\gloss{lookback area}强调如果R1未能在其位置找到更新，将继续探索的区域。经过一段等待R1解析的短时间(可配置参数\gloss{head start})后，算法开始探索前视区和后视区，分别由$\langle  12, 2 \rangle$和$\langle  4, 2 \rangle$牵头。这两个同时进行的查找在下面的图中被标记为R2，并且与R1一起活动。此外，还递归地定义了另外4个查找区域(标记为LA2和LB2)，它们取决于R2的每个实例的结果:
一旦R1解决了，我们就可以对其中一个区域进行修剪。这是通过递归地取消上下文来实现的，这将中止与它关联的所有块检索。找到的更新U9可以用作将来查找的提示

在我们的例子中，R1返回update U6，因此我们的状态如下所示。注意，U6现在被标记为黄色的“known”，因此我们确定该区域是暗红色的，虽然它可能包含其他更新，但**不包含最新的**，这是我们关心的:


同样，在短暂的提前开始之后，算法继续查找向后和向前的头$\langle  8, 2 \rangle$和$\langle  14, 1 \rangle$，标记为active(紫色)，下面的标签是R3。递归地，它们有自己的前视区和后视区，标记为LA3和LB3:

在我们的示例中，R2最终解析，找到更新U8。这意味着我们可以取消回看区域LB2，因为我们现在确定最后的更新不在那里:


为了简化示例，如果R3立即解析而没有发现更新($\langle  14, 1 \rangle$没有包含更新)，那么将取消LA3族的查找，而LB3继续(现在标记为R4):


虽然上面没有画，但很容易看到模式:LA4和LB5将分别被扫描为R5和R6，在这种情况下，失败，从而留下$\langle  12, 1 \rangle$ (U9)，作为发现的更新:


．

这个示例被简化了——使用当前的算法参数，可能会有大约30个查找并发进行，探索搜索空间以获取更新，并在找到更好的路径后递归地修剪整个分支。这可以通过调整查找超时和领先启动时间来配置。

如果算法没有找到更新(即\if U3-U9 did not actually exist), then the hint in$\langle  0, 3 \rangle$ (U2))，则会质疑其有效性:在这种情况下，如果提示实际上包含一个更新，则会返回最后一个更新，这样就完成了。然而，如果提示被证明为假，那么算法将在没有提示的情况下重新启动。


% \chapter{Implementers' guide}\label{sec:implementor-guide}
% \input{implementers-guide.tex}


% \chapter{About the project \statusred}\label{sec:about}
% \section{History \statusred}
% \section{Organisation \statusred}
% \section{Community \statusred}
% \section{Ecosystem \statusred}